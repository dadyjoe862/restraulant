"use strict";

exports.__esModule = true;
exports.default = void 0;

var g = _interopRequireWildcard(require("graphql"));

var _isArray = _interopRequireDefault(require("lodash/isArray"));

var _isPlainObject = _interopRequireDefault(require("lodash/isPlainObject"));

var _keyBy = _interopRequireDefault(require("lodash/keyBy"));

var _helpers = require("../helpers");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class QueryBuilder {
  constructor(config) {
    this.DEFAULT_LIST_FIELDS = new Set(['title', 'name', 'id']);
    this.config = config;
  }
  /**
   * returns a fragment for a type, if possible, otherwise null
   */


  getFragment(type) {
    var _this$config$resolveT;

    const getObjectFragment = (_this$config$resolveT = this.config.resolveType(type)) == null ? void 0 : _this$config$resolveT.getObjectFragment;
    if (getObjectFragment) return getObjectFragment(type);

    if (this.isScalarType(type)) {
      return '';
    }

    if (g.isObjectType(type)) {
      return `{
        ${this.getObjectTypeFragment(type, this.getSimpleScalarFields(type))}
      }`;
    }

    if (g.isListType(type)) {
      const itemType = g.getNullableType(type.ofType);

      if (this.isScalarType(itemType)) {
        return '';
      }

      if (g.isObjectType(itemType)) {
        return `{
          ${this.getObjectTypeFragment(itemType, this.getListableScalarFields(itemType))}
        }`;
      }
    }

    return undefined;
  }
  /**
   * like getFragment, but it returns also child fragments for object fields
   */


  getNestedFragment(type) {
    const objectFragments = Object.values(type.getFields()).map(field => {
      if (field.args.length !== 0) return '';
      const fragment = this.getFragment(g.getNullableType(field.type));
      if (fragment == null) return '';
      return `${field.name} ${fragment}`;
    }).filter(Boolean);
    return `{
      ${this.getObjectTypeFragment(type, objectFragments)}
    }`;
  }
  /**
   * return all scalar fields that have no arguments
   */


  getSimpleScalarFields(type) {
    return Object.values(type.getFields()).filter(f => {
      const fieldType = g.getNamedType(f.type);
      return this.isScalarType(fieldType) && f.args.length === 0;
    }).map(f => f.name);
  }

  filterListFields(field) {
    return this.DEFAULT_LIST_FIELDS.has(field) || field.endsWith('Id');
  }
  /**
   * given a type, returns only a set of common fields (name, title, id). This
   * is useful when having to display many objects, like in a table
   * @param max the maximum number of fields in the fragment
   */


  getListableScalarFields(type, filterFields = this.filterListFields.bind(this), max = 4) {
    var _this$config$resolveT2;

    const getListFragments = (_this$config$resolveT2 = this.config.resolveType(type)) == null ? void 0 : _this$config$resolveT2.getListFragments;
    if (getListFragments) return getListFragments(type);
    const simpleScalarFields = this.getSimpleScalarFields(type).filter(filterFields).slice(0, max);

    if ((0, _helpers.isNode)(type)) {
      return simpleScalarFields;
    }

    const simpleNodeFields = Object.values(type.getFields()).map(field => ({
      field,
      fType: field.type
    })).filter(({
      fType
    }) => g.isObjectType(fType) && (0, _helpers.isNode)(fType)).filter(({
      field
    }) => field.args.length === 0).map(({
      fType,
      field
    }) => {
      const subFragment = this.getObjectTypeFragment(fType, ['id', 'name', 'title'].filter(f => f in fType.getFields()));
      return `${field.name} { ${subFragment} }`;
    }); // let's go a little deeper otherwise

    return [...simpleScalarFields, ...simpleNodeFields];
  }
  /**
   * given a type, returns a GraphQL fragment string with the defined fields
   */


  getObjectTypeFragment(type, fragments) {
    const fragmentFields = fragments.join('\n');
    return `... on ${type.name} {
      __typename
      ${fragmentFields}
    }`;
  }

  serializeInputValue(input, argType) {
    const rawArgType = g.getNamedType(argType);

    if (g.isEnumType(rawArgType)) {
      return input;
    }

    if (typeof input === 'string' || typeof input === 'number' || typeof input === 'boolean' || input === null) {
      return JSON.stringify(input);
    }

    if ((0, _isArray.default)(input)) {
      const arrayItems = input.map(i => this.serializeInputValue(i, rawArgType)).join(', ');
      return `[${arrayItems}]`;
    }

    if ((0, _isPlainObject.default)(input)) {
      const objectFields = g.assertInputObjectType(rawArgType).getFields();
      const objectItems = Object.entries(input).filter(([, v]) => v !== undefined).map(([k, v]) => `${k}: ${this.serializeInputValue(v, objectFields[k].type)}`).join(', ');
      return `{${objectItems}}`;
    }

    throw new Error(`invalid type for input: ${input}`);
  }

  serializeArgsInline(args, argDefinitions) {
    const argsByName = (0, _keyBy.default)(argDefinitions, a => a.name);
    const serializedArgs = Object.entries(args).filter(([, v]) => v !== undefined).map(([k, v]) => `${k}: ${this.serializeInputValue(v, argsByName[k].type)}`).join(', ');
    return serializedArgs && `(${serializedArgs})`;
  }

  serializeVariableDefinitions(argNames, argDefinitions) {
    if (argNames.length === 0) {
      // we need to return empty strings because empty parens are not allowed
      return {
        assignements: '',
        definitions: ''
      };
    }

    const argsByName = (0, _keyBy.default)(argDefinitions, a => a.name);
    const definitions = [];
    const assignments = [];
    argNames.forEach(arg => {
      const varType = argsByName[arg].type.toString();
      const varName = `$${arg}`;
      definitions.push(`${varName}: ${varType}`);
      assignments.push(`${arg}: ${varName}`);
    });
    return {
      definitions: `(${definitions.join(', ')})`,
      assignments: `(${assignments.join(', ')})`
    };
  }

  isScalarType(type) {
    return g.isScalarType(type) || g.isEnumType(type);
  }

}

exports.default = QueryBuilder;